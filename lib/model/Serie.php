<?php


/**
 * Skeleton subclass for representing a row from the 'serie' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * 12/04/10 09:58:04
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class Serie extends BaseSerie {

	/**
	 * Initializes internal state of Serie object.
	 * @see        parent::__construct()
	 */
	public function __construct()
	{
		// Make sure that parent constructor is always invoked, since that
		// is where any default values for this object are set.
		parent::__construct();
	}
	public function __toString(){
		return sprintf('%s', $this->getTitre());
	}


	public function resizeImage(){
      $file = sfConfig::get('sf_upload_dir').DIRECTORY_SEPARATOR.'series'.DIRECTORY_SEPARATOR.$this->getImage() ;
	  
      $img = new sfImage($file) ;
      $img->resizeProp(240,320);//class ajouté dans sfImage pour redimensioner l'image proportionelement
	  //160,213
      $img->saveas($file);
      }

    public function getActeurs($nb=0){
		$acteurs = Array();
		$i=0;
		if(sizeof($this->getSaisons())>0){
			foreach($this->getSaisons() as $saison){
				if(sizeof($saison->getActeurs())>0){
					foreach($saison->getActeurs() as $act){
						if($i<$nb){
							$acteurs[]=$act;
							$i++;
						}
					}
				}
			}
		}
		array_unique($acteurs);
        return $acteurs;
    }
	
	
	  public function getProprietaires()
	  {
		$fini = false;
		$proprios=Array();
		foreach($this->getSaisons() as $i => $saison){
			if(!$fini){
				foreach($saison->getProprietaires() as $j => $admin){
					if(!in_array($admin,$proprios)){
						$proprios[]=$admin;
						if(sizeof($proprios)==sizeof(sfGuardUserPeer::getProprio())){
							break;
						}
					}
				}
			}
			
		}
		return $proprios;
	  }
	
	public function getExtraitResume(){
        // on peut remplacer par une donnée issue d'une base sql (ex: $chaine = $sql['texte'];)
        $chaine = $this->getResume();

        $lg_max = 160; //nombre de caractères autorisés

        //On vérifie si le texte est plus grand que le nombre de caractères spécifiés
        if (strlen($chaine) > $lg_max)

        //Si la réponse est non le script ne fait rien mais si c'est oui on continue...
        {
            $chaine = substr($chaine, 0, $lg_max);
            //on cherche l'espace le plus proche du maximum des caractères autorisés (ici 160)
            $last_space = strrpos($chaine, " ");
            //On ajoute ... à la suite de cet espace
            $chaine = substr($chaine, 0, $last_space);
        }

        return $chaine;
    }

    public function getResteResume(){
        // on peut remplacer par une donnée issue d'une base sql (ex: $chaine = $sql['texte'];)
        $chaine = $this->getResume();

        $lg_max = 160; //nombre de caractères autorisés

        //On vérifie si le texte est plus grand que le nombre de caractères spécifiés
        if (strlen($chaine) > $lg_max){
            $chaine2 = substr($chaine, 0, $lg_max);
            //on cherche l'espace le plus proche du maximum des caractères autorisés (ici 160)
            $last_space = strrpos($chaine2, " ");
            //On ajoute ... à la suite de cet espace
            $chaine = substr($chaine, $last_space);
        }else{
            $chaine="";
        }

        return $chaine;
    }


    public function getCategories($nb=0){
        foreach($this->getCategorieseries() as $i=>$cat){
            if($i<$nb || $nb==0){
                $categories[]=$cat->getCategorie();
            }
        }
        return $categories;
    }

	public function save(PropelPDO $con = null){
        if (!$this->getImage()=="")
		{
            $this->resizeImage();
        }		
        if (is_null($con))
        {
            $con = Propel::getConnection(SeriePeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
        }

        $con->beginTransaction();
        try
        {
            $ret = parent::save($con);
            $this->updateLuceneIndex();
            $con->commit();
            return $ret;
        }
        catch (Exception $e)
        {
            $con->rollBack();
            throw $e;
        }

    }


    public function postDelete(PropelPDO $con = null){
		// On supprime la photo si le fichier existe
        if (file_exists(sfConfig::get('sf_upload_dir') . '/series/'.$this->getImage())){
			@unlink(sfConfig::get('sf_upload_dir') . '/series/'.$this->getImage());
        }
    }

    public function updateLuceneIndex()
    {
        $index = SeriePeer::getLuceneIndex();

        // remove existing entries
        foreach ($index->find('pk:'.$this->getId()) as $hit)
        {
            $index->delete($hit->id);
        }
		  
        $doc = new Zend_Search_Lucene_Document();

        // store job primary key to identify it in the search results
        $doc->addField(Zend_Search_Lucene_Field::Keyword('pk', $this->getId()));

        // index job fields
        $doc->addField(Zend_Search_Lucene_Field::UnStored('titre', VideoPeer::clean($this->getTitre()), 'utf-8'));
        $doc->addField(Zend_Search_Lucene_Field::UnStored('titre_original', VideoPeer::clean($this->getTitreOriginal()), 'utf-8'));
        // add job to the index
        $index->addDocument($doc);
        $index->commit();
    }

    public function delete(PropelPDO $con = null)
    {
        $index = SeriePeer::getLuceneIndex();

        foreach ($index->find('pk:'.$this->getId()) as $hit)
        {
            $index->delete($hit->id);
        }

        return parent::delete($con);
    }


    public function getRealisateur(){
		return $this->getPersonne();
    }
		
		
    public function getSaisons($criteria = null, PropelPDO $con = null){
            $crit=new Criteria();
            $crit->add(SaisonPeer::SERIE_ID,$this->getId());
            $crit->addAscendingOrderByColumn(SaisonPeer::NUMERO);

            return SaisonPeer::doSelect($crit);
    }
		
	   
	public function setTitre($v){
		$clean=VideoPeer::clean($v.$this->setSousTitre().$this->getTitreOriginal());
		$this->setTitreClean($clean);
		return parent::setTitre($v);
	}
	   
	   
	public function setSousTitre($v){
		$clean=VideoPeer::clean($this->getTitre().$v.$this->getTitreOriginal());
		$this->setTitreClean($clean);
		return parent::setSousTitre($v);
	}
	   
	public function setTitreOriginal($v){
		$clean=VideoPeer::clean($this->getTitre().$this->getSousTitre().$v);
		$this->setTitreClean($clean);
		return parent::setTitreOriginal($v);
	}

	
	   public function getFormatDureeHeure(){
			$duree=$this->getFormatDuree();
			$heures=floor($duree/60);
			$mins=$duree-($heures*60);
			if(strlen($mins)==1){
				$mins='0'.$mins;
			}
			return $heures.'h'.$mins;
	   }  




} // Serie
