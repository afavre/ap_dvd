<?php


/**
 * Skeleton subclass for representing a row from the 'personne' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * Tue Aug 23 12:38:08 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class Personne extends BasePersonne {


////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Fonctions GLOBAL ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

  public function __toString()
  {
    return sprintf('%s %s', $this->getNom(), $this->getPrenom());
  }

  public function resizeImage(){
      $file = sfConfig::get('sf_upload_dir').DIRECTORY_SEPARATOR.'personnes'.DIRECTORY_SEPARATOR.$this->getImage() ;
	  
      $img = new sfImage($file) ;
      $img->resizeProp(240,320);//class ajouté dans sfImage pour redimensioner l'image proportionelement
	  //160,213
      $img->saveas($file);
      }

	  public function save(PropelPDO $con = null){
		 if (!$this->getImage()=="")
		{
		  $this->resizeImage();
		}		
		if (is_null($con))
		{
			$con = Propel::getConnection(PersonnePeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
		}
		$con->beginTransaction();
		try
		{
		  $ret = parent::save($con);
		  $this->updateLuceneIndex();
		  $con->commit();
		  return $ret;
		}
		catch (Exception $e)
		{
		  $con->rollBack();
		  throw $e;
		}
	  }
	  
	
	
     public function getSagas($nb=0){
            $videos1 = $this->getAllFilmsActeur();
            $crit=new Criteria();
            $crit->add(VideoPeer::SAGA_ID,NULL, Criteria::NOT_EQUAL);

            $videos = VideoPeer::doSelect($crit);

            foreach($videos as $i => $video){
                    $videos2[]=$video->getId();
            }
            foreach($videos1 as $i => $video){
                if(in_array($video->getId(),$videos2)){
                    if($video->getSaga()->getId()!=$idsaga){
                        $saga[]=$video->getSaga();
                        $idsaga=$video->getSaga()->getId();
                    }
                }
            }
            return $saga;
    } 

	
     public function getAge(){
		$date_de_naissance = $this->getDateNaissance();		// La date de naissance
		$chiffre = explode('-',$date_de_naissance);            // On tri les infos
		$time_naissance = mktime(0,0,0,$chiffre[1],$chiffre[2],$chiffre[0]); // On recupere sa date de naissance en timestamp
		$seconde_vecu = time() - $time_naissance;             // On regarde combien de temps il a vecu en seconde
		$seconde_par_an = (1461*24*60*60)/4;                // On calcule le nombre de secondes en compte les années bisextilles
		$age = floor(($seconde_vecu / $seconde_par_an));    // On calcule son age
		return $age; 
	}
	
     public function getAgeMort(){
		$date_de_naissance = $this->getDateNaissance();							// La date de naissance
		$chiffre = explode('-',$date_de_naissance);            					// On tri les infos
		$time_naissance = mktime(0,0,0,$chiffre[1],$chiffre[2],$chiffre[0]); 	// On recupere sa date de naissance en timestamp
		
		$date_de_deces = $this->getDateDeces();									// La date de deces
		$chiffre2 = explode('-',$date_de_deces);            					// On tri les infos
		$time_deces = mktime(0,0,0,$chiffre2[1],$chiffre2[2],$chiffre2[0]); 	// On recupere sa date de deces en timestamp
		
		$seconde_vecu = $time_deces - $time_naissance;             				// On regarde combien de temps il a vecu en seconde
		$seconde_par_an = (1461*24*60*60)/4;                					// On calcule le nombre de secondes en compte les années bisextilles
		$age = floor(($seconde_vecu / $seconde_par_an));    					// On calcule son age
		return $age; 
	}


	public function delete(PropelPDO $con = null)
	{
	  $index = PersonnePeer::getLuceneIndex();
	 
	  foreach ($index->find('pk:'.$this->getId()) as $hit)
	  {
		$index->delete($hit->id);
	  }	 
	  return parent::delete($con);
	}

	  public function postDelete(PropelPDO $con = null){
	  // On supprime la photo si le fichier existe
		  if (file_exists(sfConfig::get('sf_upload_dir') . '/personnes/'.$this->getImage())){
			@unlink(sfConfig::get('sf_upload_dir') . '/personnes/'.$this->getImage());
		  }
	  }
	  
	  public function updateLuceneIndex()
	{
	  $index = PersonnePeer::getLuceneIndex();
	  // remove existing entries
	  foreach ($index->find('pk:'.$this->getId()) as $hit)
	  {
		$index->delete($hit->id);
	  }
	  $doc = new Zend_Search_Lucene_Document();
	  // store job primary key to identify it in the search results
	  $doc->addField(Zend_Search_Lucene_Field::Keyword('pk', $this->getId()));
	  // index job fields
	  $doc->addField(Zend_Search_Lucene_Field::UnStored('nom', VideoPeer::clean($this->getNom()), 'utf-8'));
	  $doc->addField(Zend_Search_Lucene_Field::UnStored('prenom', VideoPeer::clean($this->getPrenom()), 'utf-8'));
	  // add job to the index
	  $index->addDocument($doc);
	  $index->commit();
	}
	
	
	   public function setNom($v){
			$clean=VideoPeer::clean($this->getPrenom().$v);
			$this->setNomPrenomClean($clean);
			return parent::setNom($v);
	   }
	   
	   
	   public function setPrenom($v){
			$clean=VideoPeer::clean($v.$this->getNom());
			$this->setNomPrenomClean($clean);
			return parent::setPrenom($v);
	   }
	   
	   public function uc_strtoupper_fr($chaine){
			$chaine=strtoupper($chaine);
			$chaine=utf8_decode($chaine);
			$chaine=trim($chaine);
			$chaine = strtr($chaine, "äâàáåãéèëêòóôõöøìíîïùúûüýñçþÿæœðø","ÄÂÀÁÅÃÉÈËÊÒÓÔÕÖØÌÍÎÏÙÚÛÜÝÑÇÞÝÆŒÐØ");
			$chaine=utf8_encode($chaine);
			$chaine = str_replace('MC' ,'Mc',$chaine);
			return trim($chaine);
	   }
		public function uc_ucfirst_fr($mot) {
			$mot=utf8_decode($mot);
			$mot=trim($mot);
			if($mot){
				$maj=$mot[0];
				$maj = strtr($maj, "äâàáåãéèëêòóôõöøìíîïùúûüýñçþÿæœðø","ÄÂÀÁÅÃÉÈËÊÒÓÔÕÖØÌÍÎÏÙÚÛÜÝÑÇÞÝÆŒÐØ");
				$mot = substr_replace($mot,$maj,0,1);
				$mot=utf8_encode($mot);
				$mot=ucwords($mot);
			}
			return trim($mot);
		}
	   
	   public function getNom(){
			return $this->uc_strtoupper_fr(parent::getNom());
	   }
	   
	   
	   public function getPrenom(){
			return $this->uc_ucfirst_fr(strtolower(parent::getPrenom()));
	   }
	  
	
	
	
////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// Fonctions pour ACTEURS ////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////


    public function getAllFilmsActeur($pro,$nb=0){
		$u=0;
		$films = Array();
		foreach($this->getActeurvideos() as $i => $film){
			if($pro){
				if($pro->possede($film->getVideo())){
					if($u<$nb || $nb==0){
						$films[]=$film->getVideo();
						$u++;
					}
				}
			}else{
				if($u<$nb || $nb==0){
					$films[]=$film->getVideo();
					$u++;
				}
			}
		}
		return $films;
    }

    public function getFilmsActeur($pro,$nb=0){
		$films1 = $this->getAllFilmsActeur($pro);
		$crit=new Criteria();
		//$crit->add(VideoPeer::SAGA_ID,NULL);

		$films = VideoPeer::doSelect($crit);

		foreach($films as $i => $film){
				$films2[]=$film->getId();
		}
		$films3 = Array();
		foreach($films1 as $i => $film){
			if(in_array($film->getId(),$films2)){
				$films3[]=$film;
			}
		}
		return $films3;
    }
	
    public function getAllSaisonsActeur($pro,$nb=0){
		$u=0;
		$saisons = Array();
		foreach($this->getActeurseries() as $i => $saison){
			if($pro){
				if($pro->possedeSaison($saison->getSaison())){
					if($u<$nb || $nb==0){
						$saisons[]=$saison->getSaison();
						$u++;
					}
				}
			}else{
				if($u<$nb || $nb==0){
					$saisons[]=$saison->getSaison();
					$u++;
				}
			}
		}
		return $saisons;
    }
	
    public function getSaisonsActeur($pro,$nb=0){
		$saisons1 = $this->getAllSaisonsActeur($pro);
		$crit=new Criteria();
		//$crit->add(VideoPeer::SAGA_ID,NULL);

		$saisons = SaisonPeer::doSelect($crit);

		foreach($saisons as $i => $saison){
				$saisons2[]=$saison->getId();
		}
		$saisons3 = Array();
		foreach($saisons1 as $i => $saison){
			if(in_array($saison->getId(),$saisons2)){
				$saisons3[]=$saison;
			}
		}
		return $saisons3;
    }
	   
	   
	   
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////// Fonctions pour REALISATEURS /////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
	   
	   
    public function getFilmsRealisateur($pro){
		$films = Array();
		foreach($this->getFilms() as $i => $film){
			if($pro){
				if($pro->possede($film)){
						$films[]=$film;
				}
			}else{
					$films[]=$film;
			}
		}
		return $films;
    }
	
    public function getSaisonsRealisateur($pro){
		$saisons = Array();
		foreach($this->getSaisons() as $i => $saison){
			if($pro){
				if($pro->possedeSaison($saison)){
						$saisons[]=$saison;
				}
			}else{
					$saisons[]=$saison;
			}
		}
		return $saisons;
    }
	
    public function getSpectaclesAuteur($pro){
		$spectacles = Array();
		foreach($this->getSpectacles() as $i => $spectacle){
			if($pro){
				if($pro->possede($spectacle)){
						$spectacles[]=$spectacle;
				}
			}else{
					$spectacles[]=$spectacle;
			}
		}
		return $spectacles;
    }
	
    public function getFilms(){
            $crit=new Criteria();
            $crit->add(VideoPeer::TYPE,'film');
            $crit->add(VideoPeer::REALISATEUR_ID,$this->getId());

            return VideoPeer::doSelect($crit);
    }
	
    public function getSaisons($criteria = null, PropelPDO $con = null){
            $crit=new Criteria();
            $crit->add(SaisonPeer::REALISATEUR_ID,$this->getId());

            return SaisonPeer::doSelect($crit);
    }
	
    public function getSpectacles(){
            $crit=new Criteria();
            $crit->add(VideoPeer::TYPE,'spectacle');
            $crit->add(VideoPeer::REALISATEUR_ID,$this->getId());

            return VideoPeer::doSelect($crit);
    }
	
	
public function uploadImageUrl($url) {
	$repertoire = sfConfig::get('sf_upload_dir').DIRECTORY_SEPARATOR.'personnes'.DIRECTORY_SEPARATOR;
	$er=0;
	$url_ary = Array();
	if(!preg_match('/^(http:\/\/)?([\w\-\.]+)\:?([0-9]*)\/(.*)$/', $url, $url_ary)){
		$er=1;
	}
	if(empty($url_ary[4])){
		$er=1;
	}
	if($er==1) {
		return false;
	}else{
		$maxsize = 100000000;
		
		$base_filename = substr($url_ary[4],strrpos($url_ary[4],"/")+1);
		
		$tab_name = explode(".",$base_filename);
		$name = $tab_name[0];
		$extension = $tab_name[1];
		$base_filename = sha1($name.rand(11111, 99999)).'.'.$extension;
	
		$base_get = '/' . $url_ary[4];
		$port = ( !empty($url_ary[3]) ) ? $url_ary[3] : 80;

		if($base_filename==""){
			return false;
		}

		if (!($fsock = fsockopen($url_ary[2], $port, $errno, $errstr))){
			return false;
		}

		fputs($fsock, "GET $base_get HTTP/1.1\r\n");
		fputs($fsock, "Host: " . $url_ary[2] . "\r\n");
		fputs($fsock, "Accept-Language: fr\r\n");
		fputs($fsock, "Accept-Encoding: none\r\n");
		fputs($fsock, "User-Agent: PHP\r\n");
		fputs($fsock, "Connection: close\r\n\r\n");

		unset($data);
		while(!feof($fsock)){
			$data .= fread($fsock, $maxsize);
		}
		fclose($fsock);

		if (!preg_match('#Content-Length\: ([0-9]+)[^ /][\s]+#i', $data, $file_data1) || !preg_match('#Content-Type\: image/[x\-]*([a-z]+)[\s]+#i', $data, $file_data2)){
			return false;
		}

		$filesize = $file_data1[1]; 
		$filetype = $file_data2[1]; 

		if (!$error && $filesize > 0 && $filesize < $maxsize){
			$data = substr($data, strlen($data) - $filesize, $filesize);

			$filename = $repertoire.$base_filename;

			if(file_exists($filename)){
				return false;
			}else{
				$fptr = fopen($filename, 'wb');
				$bytes_written = fwrite($fptr, $data, $filesize);
				fclose($fptr);
		
				if ($bytes_written != $filesize){
					unlink($tmp_filename);
					return false;
				}
				$this->setImage($base_filename);
				$this->resizeImage();
				return true;
			}
		}else{
			return false;
		}
	}
}
	
	

} // Personne
